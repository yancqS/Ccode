#include <stdio.h>
#include <stdlib.h>
//变量作用域和修饰符
/*
作用域,同一作用域内不许重名
局部变量，大括号以内的变量叫做 局部变量,包含可形参列表中的形参。其作用域，起始于定义处，截止于所在的大括号。
若未赋值，其值是随机的。
{}以内的 {} 不会影响执行流程。
*/

/*全局变量 大括号以外的变量是全局变量。其作用域始于定义处，截止于本文件结束。
若未赋值，其值将初始化为0。

局部变量生命周期开始于 所在函数调用，结束于所在函数调用完毕。
main()有操作系统发起调用，main()函数局部变量生命周期等同于main() , 进程。
全局变量的生命周期同进程，开始于main()函数调用,结束于main()函数的结束。具有整个进程的生命周期
main函数中的局部变量 同 全局变量的生命周期是一样的。但是他们的使用范围是不一样的。*/

/*修饰符 auto : 只能修饰局部变量,可以省略,局部变量若无其他修饰,则默认为auto.其特点是: 随用随开，用完即消。
      register 只修饰局部变量。
      extern 只修饰全局变量,全局变量本身是全局可用的，但是由于文件是单个执行的，并且编译时至上而下的，所以对于
不是本范围内定义的全局变量，要想使用必须用extern进行声明，如果不加上extern，就会造成重定义。
注意: 经extern声明的变量，不可以再初始化。*/

/*
static 既可以修饰局部变量，也可以修饰全局变量。

修饰局部变量，修改了局部变量的声明周期，使其生命周期同 进程或是main函数。static变量若未初始化，则系统初始化为0.
并且只进行一次初始化。

修饰全局变量，限制了它的外延性。使其仅成为在本文件内部使用的全局变量。这样既保留了全局变量的使用便利性，又不会
造成全局空间的命名污染。

*/
extern int b;//用extern进行 声明,不可以进行初始化。(类似于函数的前向声明) 同样，声明可以多次，定义只能一次。
void fun();

int main() {
    int a = 3;
    {
        int a = 6;
        printf("a = %d\n", a);
    }
    printf("a = %d\n", a);
    printf("b = %d\n", b);

    for (int i = 0; i < 10; i++) {
        fun();
    }

    return 0;
}

int b = 5;//定义
void fun() {
    int i = 1;
    static int j = 1;
    printf("i = %d, j = %d\n", i++, j++);
}

